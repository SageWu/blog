## 基本概念
* 栈：后进先出的线性数据结构，用来存储函数执行过程中的局部变量和参数，当调用其他函数时，还会存储栈帧底部地址、下一个指令地址。
* 栈帧：每个函数调用都有其对应的栈帧。

## 调用过程
c++源码
```cpp
int add(int a, int b)
{
  int tmp = 0;
  tmp = a + b;

  return tmp;
}  

int main(void)
{
  int a = 1;
  int b = 2;
  int c = 3;
  int d = 4;
  int res = add(a, b);

  return 0;
}
```
生成如下汇编代码，第一列代表指令地址，第二列代表指令在函数中的地址偏移量，第三列为汇编指令。
* `rbp`指栈底指针寄存器
* `rsp`指栈顶指针寄存器
* `rip`指指令指针寄存器
```
main function
0x0000555555554681 <+0>:     push   %rbp
0x0000555555554682 <+1>:     mov    %rsp,%rbp
0x0000555555554685 <+4>:     sub    $0x20,%rsp
0x0000555555554689 <+8>:     movl   $0x1,-0x4(%rbp)
0x0000555555554690 <+15>:    movl   $0x2,-0x8(%rbp)
0x0000555555554697 <+22>:    movl   $0x3,-0xc(%rbp)
0x000055555555469e <+29>:    movl   $0x4,-0x10(%rbp)
0x00005555555546a5 <+36>:    mov    -0x8(%rbp),%edx
0x00005555555546a8 <+39>:    mov    -0x4(%rbp),%eax
0x00005555555546ab <+42>:    mov    %edx,%esi
0x00005555555546ad <+44>:    mov    %eax,%edi
0x00005555555546af <+46>:    callq  0x555555554660 <_Z3addii>
0x00005555555546b4 <+51>:    mov    %eax,-0x14(%rbp)
0x00005555555546b7 <+54>:    mov    $0x0,%eax
0x00005555555546bc <+59>:    leaveq 
0x00005555555546bd <+60>:    retq

add function
0x0000555555554660 <+0>:     push   %rbp
0x0000555555554661 <+1>:     mov    %rsp,%rbp
0x0000555555554664 <+4>:     mov    %edi,-0x14(%rbp)
0x0000555555554667 <+7>:     mov    %esi,-0x18(%rbp)
0x000055555555466a <+10>:    movl   $0x0,-0x4(%rbp)
0x0000555555554671 <+17>:    mov    -0x14(%rbp),%edx
0x0000555555554674 <+20>:    mov    -0x18(%rbp),%eax
0x0000555555554677 <+23>:    add    %edx,%eax
0x0000555555554679 <+25>:    mov    %eax,-0x4(%rbp)
0x000055555555467c <+28>:    mov    -0x4(%rbp),%eax
0x000055555555467f <+31>:    pop    %rbp
0x0000555555554680 <+32>:    retq
```
执行`main+0`指令，将`_start`函数的栈底指针保存起来。执行`main+1`指令，使得`rbp`等于`rsp`。
```
rbp ---->+----------------+<--+
         |                |   |
         |                |   |
         |                |   |
         |                |   |
         |                |
         +----------------+   _start func
         |                |
         |  _start's rbp  |   |
         |                |   |
rsp ---->+----------------+<--+
         |                |
         |                |
         |                |
         |                |
         +----------------+

         +----------------+<--+
         |                |   |
         |                |   |
         |                |   |
         |                |   |
         |                |
         +----------------+   _start func
         |                |
         |  _start's rbp  |   |
         |                |   |
rbp,rsp->+----------------+<--+
         |                |
         |                |
         |                |
         |                |
         +----------------+
```
执行`main+4`指令，为`main`函数局部变量分配内存空间（以`16`字节进行对齐）。后续为局部变量赋值，通过`rbp`减去偏移量得到对应地址，即可赋值。如果有函数参数的话，则会在局部变量的内存空间后面进行分配。
```
         |                |   |
         |                |
         +----------------+   _start func
         |                |
         |  _start's rbp  |   |
         |                |   |
rbp ---->+----------------+<--+
         |                |   |
         |                |   |
         |                |   |
         |                |
         |     32bytes    |   main func
         |                |
         |                |   |
         |                |   |
rsp ---->+----------------+<--+
```
执行`main+46`指令，会将当前指令的下一个指令地址压入栈中。并将`rip`寄存器修改为新的指令地址。
```
         |                |   |
         |                |
         +----------------+   _start func
         |                |
         |  _start's rbp  |   |
         |                |   |
rbp ---->+----------------+<--+
         |                |   |
         |                |   |
         |                |   |
         |                |
         |     32bytes    |   main func
         |                |
         |                |   |
         |                |   |
         +----------------+   |
         |                |   |
         |next instruction|   |
         |                |   |
rsp ---->+----------------+<--+
```
紧接着，会执行`add+0`和`add+1`指令，把`main`函数的栈底地址保存起来，并开始`add`函数的栈帧。
```
          |                |   |
          |                |
          +----------------+   _start func
          |                |
          |  _start's rbp  |   |
          |                |   |
          +----------------+<--+
          |                |   |
          |                |   |
          |                |   |
          |                |   |
          |     32bytes    |   |
          |                |   |
          |                |   |
          |                |
          +----------------+   main func
          |                |
          |next instruction|   |
          |                |   |
          +----------------+   |
          |                |   |
          |   main's rbp   |   |
          |                |   |
rbp,rsp ->+----------------+<--+
          |                |   |
          |                |   |
          |                |
          |      ...       |   add func
```
执行`add+31`和`add+32`指令，则会恢复`main`函数栈底指针，并把`rip`更新为之前保存的`main`函数的下一个指令地址，接着继续执行`main`函数。

## 其它
* 栈内存对齐：由于处理器每次读取内存的颗粒度为多个字节(2^n)，当要获取未对齐的地址存放的数据时，需要多次读内存以及其他操作，比较费时。